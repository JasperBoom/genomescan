#!/usr/bin/env python3

# -----------------------------------------------------------------------------
# GenomeScan internship repository.
# Copyright (C) 2023 Jasper Boom

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# Contact information: info@jboom.org.
# -----------------------------------------------------------------------------

# Imports:
import argparse
import gzip
import multiprocessing
import os
import pandas


class Collect:
    """
    The Collect class:
        This function creates a number of class attributes:
            vcf_files = a skeleton dictionary with two keys (FULL and
                        PASS_ONLY), the values are lists to be filled with full
                        paths to vcf files.
            vcf_sets = a empty dictionary to store vcf file combinations for
                       each tested minimal priority score.s
    """

    vcf_files = {"/FULL": [], "/PASS_ONLY": []}
    vcf_sets = {}

    def __init__(self, results_directory):
        """
        The initializer function:
            This function creates an instance attribute:
                results_directory = a string with the full path to the
                                    directory in which the exomiser results are
                                    stored.
        """
        self.results_directory = results_directory

    def collect_result_files(self):
        """
        The collect_result_files function:
            This function adds the vcf files generated by exomiser, found in
            the results_directory to either the FULL or PASS_ONLY list in the
            predefined dictionary vcf_files. The vcf files are identified by
            their .vcf.gz file extension.
        """
        for mode in self.vcf_files:
            for root, dirs, files in os.walk(self.results_directory + mode):
                for file in files:
                    if file.endswith(".vcf.gz"):
                        self.vcf_files[mode].append(os.path.join(root, file))

    def link_result_files(self):
        """
        The link_result_files function:
            This function splits the vcf_files dictionary into a new
            dictionary, by grouping the FULL and PASS_ONLY vcf files on the
            minimal priority score that was used to generate them. This score
            is identified by the subfolder in which the vcf is stored. This
            score will be the key whilst a list of two vcf files will be the
            value. The new dictionary is returned.
        """
        for mode, files in self.vcf_files.items():
            for file in files:
                value = float(file.split("/")[-2])
                if value not in self.vcf_sets:
                    self.vcf_sets[value] = []
                self.vcf_sets[value].append(file)
        return self.vcf_sets


class Tabular:
    """
    The Tabular class:
        This class gets a set of vcf files, an output location and a minimal
        priority score. The vcf files are processed in order to fill a
        dataframe with exomiser annotation and both predicted and known class
        information. This dataframe is written to a tsv file.

        This function creates a number of class attributes:
            column_names = a list containing all headers of annotation that
                           exomiser adds to the vcf info field.
            dataframes = an empty pandas dataframe that is filled with several
                         functions in this class.
    """

    column_names = [
        "RANK",
        "ID",
        "GENE_SYMBOL",
        "ENTREZ_GENE_ID",
        "MOI",
        "P-VALUE",
        "EXOMISER_GENE_COMBINED_SCORE",
        "EXOMISER_GENE_PHENO_SCORE",
        "EXOMISER_GENE_VARIANT_SCORE",
        "EXOMISER_VARIANT_SCORE",
        "CONTRIBUTING_VARIANT",
        "WHITELIST_VARIANT",
        "FUNCTIONAL_CLASS",
        "HGVS",
        "EXOMISER_ACMG_CLASSIFICATION",
        "EXOMISER_ACMG_EVIDENCE",
        "EXOMISER_ACMG_DISEASE_ID",
        "EXOMISER_ACMG_DISEASE_NAME",
    ]
    dataframes = {}

    def __init__(
        self, minimal_priority_score, vcf_collection, results_directory
    ):
        """
        The initializer function:
            This function creates an instance attribute:
                minimal_priority_score = a float that represents the minimal
                                         priority score used to generate the
                                         exomiser results.
                vcf_collection = a set of two vcf files from exomiser, one with
                                 with all variants and one with just the
                                 variants that passed all filters.
                results_directory = a string with the full path to the output
                                    directory used by exomiser.
        """
        self.minimal_priority_score = minimal_priority_score
        self.vcf_collection = vcf_collection
        self.results_directory = results_directory

    @property
    def vcf_collection(self):
        """
        The vcf_collection property function:
            This function converts vcf_collection to a property which results
            in a corrected list that is returned.
        """
        return self._vcf_collection

    @vcf_collection.setter
    def vcf_collection(self, value):
        """
        The vcf_collection setter function:
            This function checks if the two vcf files in the list are in the
            expected order, the first item should be PASS_ONLY, the second
            FULL. If this is not the case switch the items around.
        """
        if "PASS_ONLY" in value[0] and "FULL" in value[1]:
            self._vcf_collection = value
        elif "PASS_ONLY" not in value[0] or "FULL" not in value[1]:
            self._vcf_collection = [value[1], value[0]]

    def write_tsv(self):
        """
        The write_tsv function:
            This function writes a pandas dataframe to a file using tabs as
            a separator.
        """
        self.dataframes["FULL"].to_csv(
            self.results_directory
            + "/"
            + self.vcf_collection[1].split("/")[-3]
            + "_"
            + self.minimal_priority_score
            + "_"
            + self.vcf_collection[1].split("/")[-1].split(".")[0]
            + ".tsv",
            sep="\t",
            header=True,
            index=False,
        )

    def create_tsv(self):
        """
        The create_tsv function:
            This function creates an empty dataframe with columns corresponding to
        the different info fields that exomiser adds to the vcf file. Then
        a vcf file is processed so that the known class and the exomiser info
        are extracted and written to the empty dataframe. If the vcf only
        contains variants that passed all filters, we consider them pathogenic.
        If the vcf contains all variants, a check is performed against the
        pass only vcf, which are pathogenic, the other variants are considered
        benign. This dataframe is returned.

            This function fills an empty dataframe with columns corresponding
            to the different exomiser annotations added to the vcf info field.
            Then a vcf file is processed to fill the dataframe with the
            class information and exomiser annotation. If the vcf contains only
            variants that passed the filters, they are considered pathogenic.
            If all variants are in the vcf, a check is performed against the
            list of pathogenic variants, matches are again classified
            pathogenic, the others are benign.
        """
        self.dataframes = {
            mode: pandas.DataFrame(columns=self.column_names)
            for mode in ["PASS_ONLY", "FULL"]
        }
        for vcf in self.vcf_collection:
            mode = vcf.split("/")[-3]
            with gzip.open(vcf, "r") as file:
                for line in file:
                    correct_format_line = str(line, "latin-1")
                    if correct_format_line.startswith("#"):
                        continue
                    info = correct_format_line.split("\t")[7].split(";")
                    known_class = next(
                        (
                            item.strip("Class=")
                            for item in info
                            if item.startswith("Class=")
                        ),
                        "",
                    )
                    exomiser_info = next(
                        (
                            item.strip("Exomiser=")
                            .split(",")[0]
                            .strip("{}")
                            .split("|")
                            for item in info
                            if item.startswith("Exomiser=")
                        ),
                        [""] * 18,
                    )
                    exomiser_info.extend([""] * (18 - len(exomiser_info)))
                    info_dictionary = dict(
                        zip(self.column_names, exomiser_info)
                    )
                    info_dictionary["KNOWN_CLASS"] = known_class
                    if mode == "PASS_ONLY":
                        info_dictionary["PREDICTED_CLASS"] = "Pathogenic"
                    elif mode == "FULL":
                        check_class = any(
                            self.dataframes["PASS_ONLY"]["ID"].isin(
                                [info_dictionary["ID"]]
                            )
                        )
                        info_dictionary["PREDICTED_CLASS"] = (
                            "Pathogenic" if check_class else "Benign"
                        )
                    self.dataframes[mode] = pandas.concat(
                        [
                            self.dataframes[mode],
                            pandas.DataFrame([info_dictionary]),
                        ]
                    )
        self.write_tsv()


def process_set(minimal_priority_score, vcf_set, results_folder):
    """
    The process_set function:
        This function is used to call the Tabular class for a set of vcf files.
        It creates a Tabular object and calls the create_tsv function in order
        to generate a tsv file with exomiser results.
    """
    file_set = Tabular(minimal_priority_score, vcf_set, results_folder)
    file_set.create_tsv()


def parse_argvs():
    """
    The parse_argvs function:
        This function handles all positional arguments that the script accepts,
        including version and help pages.
    """
    description = "."
    epilog = "This python script has no dependencies."
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-r",
        "--results",
        action="store",
        dest="results_folder",
        type=str,
        default=argparse.SUPPRESS,
        help="the full path to the main folder with the exomiser results.",
    )
    parser.add_argument(
        "-c",
        "--cores",
        action="store",
        dest="cores",
        type=int,
        default=1,
        help="the number of cpu cores to assign to multiprocessing",
    )
    parser.add_argument(
        "-v", "--version", action="version", version="%(prog)s [1.0]]"
    )
    argvs = parser.parse_args()
    return argvs


def main():
    """
    The main function:
        This function calls all processing functions in correct order.
    """
    user_arguments = parse_argvs()
    collection = Collect(user_arguments.results_folder)
    collection.collect_result_files()
    vcf_collection = collection.link_result_files()
    pool = multiprocessing.Pool(processes=user_arguments.cores)
    pool.starmap(
        process_set,
        [
            (key, value, user_arguments.results_folder)
            for key, value in vcf_collection.items()
        ],
    )
    pool.close()
    pool.join()


if __name__ == "__main__":
    main()

# Additional information:
# =======================
#
