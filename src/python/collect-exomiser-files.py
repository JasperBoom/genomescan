#!/usr/bin/env python3

# -----------------------------------------------------------------------------
# GenomeScan internship repository.
# Copyright (C) 2023 Jasper Boom

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# Contact information: info@jboom.org.
# -----------------------------------------------------------------------------

# Imports:
import argparse
import multiprocessing
import os
import re
from cyvcf2 import VCF


class Collect:
    """
    The Collect class:
        This function creates a number of class attributes:
            vcf_files = a skeleton dictionary with two keys (FULL and
                        PASS_ONLY), the values are lists to be filled with full
                        paths to vcf files.
            vcf_sets = a empty dictionary to store vcf file combinations for
                       each tested minimal priority score.s
    """

    vcf_files = {"/FULL": [], "/PASS_ONLY": []}
    vcf_sets = {}

    def __init__(self, results_directory):
        """
        The initializer function:
            This function creates an instance attribute:
                results_directory = a string with the full path to the
                                    directory in which the exomiser results are
                                    stored.
        """
        self.results_directory = results_directory

    def collect_result_files(self):
        """
        The collect_result_files function:
            This function adds the vcf files generated by exomiser, found in
            the results_directory to either the FULL or PASS_ONLY list in the
            predefined dictionary vcf_files. The vcf files are identified by
            their .vcf.gz file extension.
        """
        for mode in self.vcf_files:
            for root, _, files in os.walk(self.results_directory + mode):
                for file in files:
                    if file.endswith(".vcf.gz"):
                        self.vcf_files[mode].append(os.path.join(root, file))

    def link_result_files(self):
        """
        The link_result_files function:
            This function splits the vcf_files dictionary into a new
            dictionary, by grouping the FULL and PASS_ONLY vcf files on the
            minimal priority score that was used to generate them. This score
            is identified by the subfolder in which the vcf is stored. This
            score will be the key whilst a list of two vcf files will be the
            value. The new dictionary is returned.
        """
        for _, files in self.vcf_files.items():
            for file in files:
                value = float(file.split("/")[-2])
                if value not in self.vcf_sets:
                    self.vcf_sets[value] = []
                self.vcf_sets[value].append(file)
        return self.vcf_sets


class Tabular:
    """
    The Tabular class:
        This class gets a set of vcf files, an output location and a minimal
        priority score. The vcf files are processed in order to fill a
        dataframe with exomiser annotation and both predicted and known class
        information. This dataframe is written to a tsv file.

        This function creates a number of class attributes:
            column_names = a list containing all headers of annotation that
                           exomiser adds to the vcf info field.
            dataframes = an empty pandas dataframe that is filled with several
                         functions in this class.
    """

    column_names = [
        "RANK",
        "ID",
        "GENE_SYMBOL",
        "ENTREZ_GENE_ID",
        "MOI",
        "P-VALUE",
        "EXOMISER_GENE_COMBINED_SCORE",
        "EXOMISER_GENE_PHENO_SCORE",
        "EXOMISER_GENE_VARIANT_SCORE",
        "EXOMISER_VARIANT_SCORE",
        "CONTRIBUTING_VARIANT",
        "WHITELIST_VARIANT",
        "FUNCTIONAL_CLASS",
        "HGVS",
        "EXOMISER_ACMG_CLASSIFICATION",
        "EXOMISER_ACMG_EVIDENCE",
        "EXOMISER_ACMG_DISEASE_ID",
        "EXOMISER_ACMG_DISEASE_NAME",
        "KNOWN_CLASS",
        "PREDICTED_CLASS",
    ]
    dataframes = {}

    def __init__(
        self, minimal_priority_score, vcf_collection, results_directory
    ):
        """
        The initializer function:
            This function creates an instance attribute:
                minimal_priority_score = a float that represents the minimal
                                         priority score used to generate the
                                         exomiser results.
                vcf_collection = a set of two vcf files from exomiser, one with
                                 with all variants and one with just the
                                 variants that passed all filters.
                results_directory = a string with the full path to the output
                                    directory used by exomiser.
        """
        self.minimal_priority_score = minimal_priority_score
        self.vcf_collection = vcf_collection
        self.results_directory = results_directory

    @property
    def vcf_collection(self):
        """
        The vcf_collection property function:
            This function converts vcf_collection to a property which results
            in a corrected list that is returned.
        """
        return self._vcf_collection

    @vcf_collection.setter
    def vcf_collection(self, value):
        """
        The vcf_collection setter function:
            This function checks if the two vcf files in the list are in the
            expected order, the first item should be PASS_ONLY, the second
            FULL. If this is not the case switch the items around.
        """
        if "PASS_ONLY" in value[0] and "FULL" in value[1]:
            self._vcf_collection = value
        else:
            self._vcf_collection = [value[1], value[0]]

    def parse_exomiser_info(self, info_field):
        """
        The parse_exomiser_info function:
            This function selects a string in between two brackets. It selects
            the first element/group and splits on a pipe character. The list is
            returned.
        """
        match = re.match(r"\{([^{}]+)\}", info_field)
        if match:
            first_set = match.group(1)
            elements = first_set.split("|")
            return elements
        else:
            return []

    def create_tsv(self):
        """
        The create_tsv function:
            This function creates an empty dataframe with columns corresponding
            to the different info fields that exomiser adds to the vcf file.
            Then a vcf file is processed so that the known class and the
            exomiser infoare extracted and written to the empty dataframe. If
            the vcf only contains variants that passed all filters, we consider
            them pathogenic. If the vcf contains all variants, a check is
            performed against the pass only vcf, which are pathogenic, the
            other variants are considered benign. This dataframe is returned.

            This function fills an empty dataframe with columns corresponding
            to the different exomiser annotations added to the vcf info field.
            Then a vcf file is processed to fill the dataframe with the
            class information and exomiser annotation. If the vcf contains only
            variants that passed the filters, they are considered pathogenic.
            If all variants are in the vcf, a check is performed against the
            list of pathogenic variants, matches are again classified
            pathogenic, the others are benign.
        """
        pass_only_ids = []
        for vcf_file in self.vcf_collection:
            mode = vcf_file.split("/")[-3]
            output_file = (
                self.results_directory
                + "/"
                + str(mode)
                + "_"
                + str(f"{float(self.minimal_priority_score):.2f}")
                + ".tsv"
            )
            with open(output_file, "w") as file_out:
                file_out.write("\t".join(self.column_names) + "\n")
                vcf = VCF(vcf_file)
                for variant in vcf:
                    known_class = variant.INFO.get("Class", "N/A")
                    exomiser_info = self.parse_exomiser_info(
                        variant.INFO.get("Exomiser", "N/A")
                    )
                    info_dictionary = dict(
                        zip(self.column_names, exomiser_info)
                    )
                    info_dictionary["KNOWN_CLASS"] = known_class
                    if mode == "PASS_ONLY":
                        info_dictionary["PREDICTED_CLASS"] = "Pathogenic"
                        pass_only_ids.append(info_dictionary["ID"])
                    elif mode == "FULL":
                        predicted_class = (
                            "Pathogenic"
                            if info_dictionary["ID"] in pass_only_ids
                            else "Benign"
                        )
                        info_dictionary["PREDICTED_CLASS"] = predicted_class
                    info_dictionary["EXOMISER_ACMG_CLASSIFICATION"] = "UNKNOWN"
                    info_dictionary["EXOMISER_ACMG_EVIDENCE"] = "UNKNOWN"
                    info_dictionary["EXOMISER_ACMG_DISEASE_ID"] = "UNKNOWN"
                    info_dictionary["EXOMISER_ACMG_DISEASE_NAME"] = "UNKNOWN"
                    file_out.write(
                        "\t".join(
                            str(info_dictionary.get(col, ""))
                            for col in self.column_names
                        )
                        + "\n"
                    )


def process_set(minimal_priority_score, vcf_set, results_folder):
    """
    The process_set function:
        This function is used to call the Tabular class for a set of vcf files.
        It creates a Tabular object and calls the create_tsv function in order
        to generate a tsv file with exomiser results.
    """
    file_set = Tabular(minimal_priority_score, vcf_set, results_folder)
    file_set.create_tsv()


def parse_argvs():
    """
    The parse_argvs function:
        This function handles all positional arguments that the script accepts,
        including version and help pages.
    """
    description = "."
    epilog = "This python script has no dependencies."
    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-r",
        "--results",
        action="store",
        dest="results_folder",
        type=str,
        default=argparse.SUPPRESS,
        help="the full path to the main folder with the exomiser results.",
    )
    parser.add_argument(
        "-c",
        "--cores",
        action="store",
        dest="cores",
        type=int,
        default=1,
        help="the number of cpu cores to assign to multiprocessing",
    )
    parser.add_argument(
        "-v", "--version", action="version", version="%(prog)s [1.0]]"
    )
    argvs = parser.parse_args()
    return argvs


def main():
    """
    The main function:
        This function calls all processing functions in correct order.
    """
    user_arguments = parse_argvs()
    collection = Collect(user_arguments.results_folder)
    collection.collect_result_files()
    vcf_collection = collection.link_result_files()
    pool = multiprocessing.Pool(processes=user_arguments.cores)
    pool.starmap(
        process_set,
        [
            (key, value, user_arguments.results_folder)
            for key, value in vcf_collection.items()
        ],
    )
    pool.close()
    pool.join()


if __name__ == "__main__":
    main()

# Additional information:
# =======================
#
